* technics  
** i=sqrt(n) and i*i = n

** To find log2 N = log10 N/log10 2, because we cannot find the log2 in java. we can find log10 or loge

** bitwise mask number finding 1<<n.

** count the number can be find by log10(n).


** kadane algo (find largest subarray of sum)
   - commuity helping algo 
** Boyer-Moore majority voting algorithm ()
   - 

* number
** 1 factorial of a number(5! = 1*2*3*4*5 = 120)


** 2 count the number of digits
*** normal method(uses reverse, palandrome, armstrong number,) 
*** short-cut is Math.log10(n) 


** 3 number of Trailing Zeros in a Factorial
eg. 5! = 120 = trailing zero is 1 which means last have 1 zero
    10!= 3628800= 2 which means last have 2 zeros
*** normal method is do 
    - factorial of digits
    - count the number of zero by count the digit
*** short-cut is when 
    - n/5 + n/25 + n/125 + n/625 + n/3125
eg. n=200
 200/5 + 200/25 + 200/125 + 200/625.

**** Code
    private static void trailingZero(int n) {
		int res =0,div=5 ;
		while(n>=div)
		{
			res += n/div;
			div *= 5;
		}
		System.out.println(res);
	}
	

** 4 find GCD of HCF
 hcf a = 20 and b =15

divisor or factor of 20 = 1,2,4,5,10,20
                     15 = 1,3,5,15

common factor b/w a and b = 1, 5

greater common factor means is 5

*** normal solution O(min(a,b)) (larger number goes the time also go larger) 0(n)
 1) find the minimum of both a & b
 2) use a for loop and start from i = min and go till one
 3) Inside the loop, check if i is a common divisor
 4) If if is a common divisor, return i;

**** code 
private static void normalMethod(int n, int m) {
		int no = n>m ? n : m;
		while(no>0)
		{
			if(n%no==0 && m % no==0)
				break;
			no--;
		}
		System.out.println(no);
	}



*** Euclid method O(max(a,b)) better then normal solution
    1) find the larger number
    2) Replace the larger number by the minus the larger and smaller number
    3) Repeat step 1 and 2 until both numbers become equal
    4) Return any one number, which is the GCD
**** code
private static void eucliddMethod(int a, int b) 
{
	while(a!=b)
	{
		if(a>b)
			a= a-b;
		else
			b= b-a;
	}
	System.out.println(a+" "+b);
}


*** more optimize and efficient O(log(min(a,b)))
    1) find the large number
    2) large value is modular large and small
    3) repeat until the anyone value is equal to zero.

**** code 
private static void eucliddMethod(int a, int b) 
{
	while(a!=0 && b!=0)
	{
		if(a>b)
		      a=a%b;
		else
		      b=b%a;
	}
	System.out.println(a+" "+b);
}


** 5 find lcm (least common multiple)

multiples of 2 = 2 4 6 8 10 12 14 16 18 20 . . . . . .
multiples of 5 = 5 10 15 20 . . . . . . 

lcm is 10, 10 is least and common multiples for 2, 5

start loop from 5 
*** Brute Force approach
    1) temp varible to store the 

**** code 
private static void findLCM(int a, int b) {
		
		int res = Math.max(a, b);
		
		while(true)
		{
			if(res%a==0 && res%b==0)
				break;
			res++;
		}
			System.out.println(res);
	}
*** more efficient code LCM(a,b) = a*b/GCD(a,b)
    1) we know to calculate the Gcd(a,b) and multiple with a and b
       
       LCM (a,b) = a * b / GCD(a,b)

**** code
private static void easyLCM(int i, int j) {
	System.out.println(i*j/gcd(i,j));
}

private static int gcd(int i, int j) {
	while(i!=0 && j!=0)
	{
		if(i>j)
			i=i%j;
		else
			j=j%i;
	}
	System.out.println(i);
	return i;
}


** 6 check for Prime numbers 
*** normal method

**** Code
private static boolean isPrimeNumberNormal(int n) 
{
	for(int i = 2;i<=n/2;i++)
		if(n%i==0)
			return false;
		return true;
}

*** the prime number should be root a number or before the root of a number (i*i<=n equalsto i<=Math.sqrt(n))
    - so iterate i=2 upto i<=sqrt(n)
    - better compare to preview method.
**** code
private static boolean isPrimeNumberNormal(int n) 
{
	for(int i = 2;i<=Math.sqrt(n);i++)
		if(n%i==0)
			return false;
		return true;
}

*** increament by 6

|----+----+----+----+----+----|
|  1 |  2 |  3 |  4 |  5 |  6 |
|  7 |  8 |  9 | 10 | 11 | 12 |
| 13 | 14 | 15 | 16 | 17 | 18 |
| 19 | 20 | 21 | 22 | 23 | 24 |
| 25 | 26 | 27 | 28 | 29 | 30 |
| 31 | 32 | 33 | 34 | 35 | 36 |
| 37 | 38 | 39 | 40 | 41 | 42 |
| 43 | 44 | 45 | 46 | 47 | 48 |
| 49 | 50 | 51 | 52 | 53 | 54 |
| 55 |    |    |    |    |    |

1) see the above table 1 is either prime nor composite number. So condition false.
2) n == 2 or 3 then return as true.
3) then see the col 2 i.e(8,14,20,26,32,38,...) and 4 i.e(10,16,22,28,34,40,...) and 6 i.e(12,18,24,30,42,48,..... ) are divisible by 2
4) then see the col 3 i.e(9,15,21,27,33,39,45,....) are divisible by 3.
5) if n%2==0 or n%3==0 are also false.
6) then here we start our loop, for (5 to sqrt(n) by increment by i=i+6) 
   - see the remaining col 1 and 5 are have prime numbers
   - so check if(n%i==0 or n%(i+2)==0) return false. 
      i.e i=5  n%5==0 or n%7==0
          i=11 n%11==0 or n%13==0
	  i=17 n%17==0 or n%19==0
   - end the loop
7) return true.

**** code
private static boolean effientMethod(int n) 
{
	if(n==1)
		return false;
	if(n==2 || n==3)
		return true;
	if(n%2==0 || n%3==0)
		return false;
	for(int i=5 ; i*i<=n ; i += 6)
		if(n%i==0 || n%(i+2)==0)
			return false;
	return true;
}


** 7 find Prime number
*** normal method

*** efficient method using boolean array 

|  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 |
| 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 |
| 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 |
| 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 |
| 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 |
| 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 |
| 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 |

**** code
private static void booleanArraymethod(int n) 
{
	boolean[] prime = new boolean[n+1];
	for(int i=2 ; i<=n ;i++)
	{
		if(prime[i] == false)
		{
			for(int j=i*2 ; j<=n ; j=j+i)
			prime[j] = true;
		}
	}
	
	for(int i=2 ;i<=n; i++)
	{
		if(prime[i]==false)
			System.out.println(i);
	}
}


*** more optimiziation method of boolean array is 1st loop from i=2 to i*i <=n or i<= Math.sqrt(n)
n=100
| number | 1st unmarked multiple            |
|--------+----------------------------------|
|      2 | 4 (6,8,10,12,14,16)              |
|      3 | 9 (6 already present)            |
|      5 | 25 (10,15,20 present)            |
|      7 | 49 (14,21,28,35,42 present)      |
|     11 | 121(before 11 number are present |    

so 11 is greater then 100 which means within 10 iteration we find prime numbers
which means sqrt of 100.
**** code 
private static void booleanArraymethod(int n) 
{
	boolean[] prime = new boolean[n+1];
	for(int i=2 ; i*i<=n ;i++) //changes here i*i <=n
	{
		if(prime[i] == false)
		{
			for(int j=i*2 ; j<=n ; j=j+i)
				prime[j] = true;
		}
	}

	for(int i=2 ;i<=n; i++)
	{
		if(prime[i]==false)
			System.out.println(i);
	}
}




** 8 divisor of a number
   n=20 divisor of a number are (1,2,4,5,10,20)
*** brute force Approach
loop from i=2 to n
check divisor or not then print the value.

**** code
private static void logEfficent(int n) 
{
	for(int i=1; i*i<=n ;i++)
	{
		if(n%i==0)
		{
			System.out.print(i+" "+n/i+" ");
		}
	}
}

*** efficient Approach O(sqrt(n))

1) Divisors can be made into pairs
n=40
| a |  b |
|---+----|
| 1 | 40 |
| 2 | 20 |
| 4 | 10 |
| 5 |  8 |
|---+----|

2) First divisor in the pair of divisors will always appear before sqrt(n) 
   a * a <=n or a <= sqrt(n)

3) second divisor can be obtained from the first divisor by using b=n/a
   b=n/a;
4) avoid the same number can print in this case i.e 5 and 25/5. It print as 5 and 5 two times
give a condition for this situation.

**** code
private static void logEfficent(int n) 
{
	for(int i=1; i*i<=n ;i++)
	{
		if(n%i==0)
		{
			System.out.print(i+" ")
			if(i != n/i)
			   System.out.print(n/i+" ");
		}
	}
}

*** print in ascending order
 write two separate loops to print one half and drecrement the another half

**** code
private static void ascendingLogEff(int n) 
{
	int i=1;
	while(i*i<=n)
	{
		if(n%i==0)
			System.out.print(i+" ");
		i++;
	}
	while(i>0)
	{
		if(n%i==0 && n/i != i)
		System.out.print(n/i+" ");
		i--;
	}
}


** 9 Prime factors of a number
*n=40*
 2*2*2*5 = 40

factor or divisor of 40 are 2,4,5,8,10,20
prime number in the factor is 2,5 

use 2*2*2*5 we get 40

*n=27*
factor or divisor of 27 are 3,9
prime number in the factor is 3 

use 3*3*3 we get 27

*do fair of this combinations*
*1st observation*
we are only going to get a single combination of prime factors
eg.

1 * 40 = 40 leave it
2 * 20 = 40 we can writen as 2*2*10 then 2*2*2*5
4 * 10 = 40 we can writen as 2*2*10 then 2*2*2*5
5 *  8 = 40 we can writen as 5*2*4  then 2*2*2*5

we got the observation.

*2nd observation*
we have  if it is prime number
*** it is not efficent for prime number
1) 1st loop for factor and 2nd loop for more than 1 times the number is divisor.
 
**** code
~
private static void simplePrimeFactor(int n) 
{
	int i=2;
	while(n>1) 
	{
		while(n%i==0)
		{
			System.out.print(i+" "+ n/i +"\n");
			n=n/i;
		}
	i++;
	}
}
~

*** used in prime number also
1) we know that the loop to find the prime number is sqrt(n) times
2) then we if (n>1) it much be prime number, so print n.

**** code
~
private static void simplePrimeFactor(int n) {
	int i=2;
	while(i*i<=n) 
	{
		while(n%i==0)
		{
			System.out.print(i+" "+ n/i+"\n");
			n=n/i;
		}
	i++;
	}
	
	// if it is prime number, n will greater then 1
	if(n>1)
		System.out.print(n);
}
~


* TODO [#9][#10][#11] bit Manipulation
  - Bit manipulation
  - Bitwise opertion
** >> (signed rightshift or arithmetic rightshift) fullers are depends on MSD  
5 >> 1
5            - 00000101
1 time shift - 00000010

it become 2

-5 >> 1
normal bits in  5 - 00000101

complement of 5   - 11111010 
2's complement    = 11111010
add one           =        1 +
=============================
                  = 11111011
1's complement or binary of -5 = 11111011 

*-5>>1*
-5      = 11111011
-5 >> 1 = (MSB)1111101 
(MSB) = 1
-5 >> 1 = 11111101

11111101
       1 -
========
11111100
then flip the bits = 00000011 = 3
change to digit = -3 

*ans for -5>>1 = -3*

How to change the -5 bit
1) take 1's compliment 
2) then do the shifting operation (MSD) is important 
3) after shifting result is -1 we get a result.
4) take complement, then we get the result.


** >>> (logical or unsigned rightshift) 0 is used for fillers


** ~ 

n = 2

binary of 2 = 00000010
         -1 =       -1
-----------------------


 


** 1) switch on / off the ith bit
switch on  - OR
switch off - compliment and And
*** switch on (OR)
eg. n = 00100100 i=3th switch on
| position                | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| binary number           | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
| mask                    | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
| binary no OR mask       | 0 | 0 | 1 | 0 | 1 | 1 | 0 | 0 |

mask is a leftshift a value up to ith time of 1. 
eg, i=3 , mask = 1 << i; // it become 0000 1000
make the bit 0010 0100 OR make. It becomes 0010 1100

**** code
~
void switchON(int n,int m)
{
   int mask = 1 << m;
   System.out.println(n OR m);
}
~


*** Switch off (compliment of mask and do AND operator)
eg. n = 0010 0100 , i=5
| position            | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| binary number       | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
| mask                | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 |
| binary no. AND mask | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |

Here the mask is ~(compliment of mask 1 << i) 


**** CODE
~
VOID SWITCHON(INT N,INT M)
{
   INT MASK = 1 << M;
   SYSTEM.OUT.PRINTLN(N OR M);
}
~


*** Toggle (flipping the bit)

n = 0010 0100, i= 5
| position                 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| binary number            | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
| mask                     | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| binary no. ^(EX-OR) mask | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |

mask is i =5, so 1 << i;
n ^ mask;

**** code
~
void Toggle(int n,int m)
{
   int mask = 1 << m;
   System.out.println(n EX-OR^ m);
}
~
*** check ON or OFF operation (given ith number is on / off with the given n)

n = 0010 0100, i= 5
| position           | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| binary number      | 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 |
| mask               | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| binary no. &  mask | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |

mask is i =5, so 1 << i;
n & mask;

**** code
~
void Toggle(int n,int m)
{
   int mask = 1 << m;
   if((n&mask)==0)
     System.out.println("OFF");
   else
    System.out.println("ON");
}
~


** 2) position of Right Most set bit 
n= 10 => 0000 1010 
set bit means value is 1.

| n   | 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |
| pos | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |

2 is the right most set bit, which means 2nd position first set bit is present.
so answer is 2.

*** brute force approch 0(logn)
1) n is assign as String.
2) loop from last-1 to 0
   1) if(charAt(i) == '1')
      return i+1;

**** code


*** using mask 0(log n)
shift the 1 one by one until we get the set bit in given number.


**** code
~
private static void firstSetBit(int n) 
{
	int m = 1, pos =1;
	if(n==0)
		System.out.println(0);
	while((n & m) == 0)
	{
		m = m<<1;
		pos++;
	}
	System.out.println(pos);
}
~

*** optimize code 0(1)
find the mask set is the task
*Algorithm *
1) given a value of n, create a mask (i.e m = (n & (n-1)))
| n               | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
| n-1             | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 1 |
| mask= n & (n-1) | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
*we can trap the sit bit*

2) perform XOR(^) between n and m and reassign it to n.

n = 40

| n        | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |
| mask     | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
| n ^ mask | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |

3) The updated value of n will have only one bit set, which will be the right most set bit.
(n^mask) is the value. But we need position.

4) formula pos = log10 (n^mask)/ log10 2, we give the position.

**** code
~
private static void maskFindAlgo(int n) {
	// find mask value
	int mask = n & (n-1);
	System.out.println(mask);
	System.out.println(n ^ mask);// here we got int value of 1000

	/*change the value to position*/
	System.out.println((int)(Math.log10(n^mask)/ Math.log10(2))+1);
		
	}
~


** 3) count set bits in a numbers
   n=43
binary n = 0 0 1 0 1 0 1 0
count 
*** brute force approach in string 0(logN)

*** kernighan's Algorithm loop 0(logN)

1) n AND n-1, we can get the right most set bit becomes unset

| n       | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| n-1     | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 |
| n & n-1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 |

2) All the bits to the left remains unchanged. After changes(2nd) position 
3) All the bits to the right becomes zero(0) . Before changes(2nd) position

| n =42          | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
| n-1=41         | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 |   |
|----------------+---+---+---+---+---+---+---+---+---|
| n =  n^n-1=40  | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 |
| n-1 =39        | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 1 |   |
|----------------+---+---+---+---+---+---+---+---+---|
| n = n^n-1 = 32 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
| n-1 =31        | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 |   |
|----------------+---+---+---+---+---+---+---+---+---|
| n= n^n-1       | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |   |

stop if n=0 and count =3;
 
**** code
~
private static void countNoSetBit(int n) 
{
	int c=0;
	while(n!=0)
	{
		n &= n-1;
		c++;
	}
	System.out.println(c);
}
~


** 4) a number is a power of 2

|-----+---------------+-------------|
|   N | Exponent form | Binary form |
|-----+---------------+-------------|
|   1 |           2^0 | 0000 0001   |
|   2 |           2^1 | 0000 0010   |
|   4 |           2^2 | 0000 0100   |
|   8 |           2^3 | 0000 1000   |
|  16 |           2^4 | 0001 0000   |
|  32 |           2^5 | 0010 0000   |
|  64 |           2^6 | 0100 0000   |
| 128 |           2^7 | 1000 0000   |
|-----+---------------+-------------|

(n & (n-1))==0 is true.


** 5) Lonely Integer 
Given an array of integer, where all elements but one occur twice. Find the unique element.

example :
a = [1,2,3,4,3,2,1]
the unique is 4.

*** brute force O(N logN) 
1) sort the array
2) then the near value is not equal to value+1 then print and break, upto n-2
3) if loop is end then print n-1.

**** code
~
private static void lonelyInteger(int[] arr) 
{
	Arrays.sort(arr);
	System.out.println(Arrays.toString(arr));
	int i=0,n=arr.length;
	while(i<n-1)
	{
		if(arr[i] != arr[i+1])
		{
			System.out.println(arr[i]);
			return;
		}
		i +=2;
	}
	System.out.println(arr[i-1]);
}
~

*** using set

*** using EX-OR operator all number of the array the one unique number can be find 
xor between two number is 0(zero)

eg. 4^4^5 = 5

**** code 
~
private static void exorOperatorMethod(int[] arr) {
	int temp = arr[0];
	for(int i = 1 ; i<arr.length ; i++)
	{
		temp ^= arr[i]; 
	}
	System.out.println(temp);
}
~



** 6) length of the longest consecutive 1's in the binary representation of number
*n =101*
                        7 6 5 4 3 2 1 0
binary representation - 0 1 1 0 0 1 0 1
consective 1's are 2, because position 6,5 are consecutive.

*n=73*
                        7 6 5 4 3 2 1 0
binary representation - 0 1 0 0 1 0 0 1
consective 1's are 0, because of no consective 1's are their.


1) check n & n<<1  
if we perform n&(n<<1) and if the there was any consecutive 1's, then we will get a non zero number.

*n=101*
| n=101    | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1 |
| n<<1     | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 |
| n & n<<1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |

n & n<<1 is not equal to zero

*n=73*
| n=73     | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 1 |
| n<<1     | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 0 |
| n & n<<1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

n & n<<1 become zero.

2) update and loop upto n=0;

eg.
| n=110    | 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1 |
| n<<1     | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 |
| n & n<<1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |

*** code
~
private static void isConsective(int n) {
	int count=0;
	while(n!=0)
	{
		n=n & (n<<1);
		count++;
	}
	System.out.println(count);
}
~


** 7) swap all even and odd bits 
n =181
              7 6 5 4 3 2 1 0
binary of n = 1 0 1 1 0 1 0 1

*separate the bits*
           8 7 6 5 4 3 2 1
odd bit  = 1   1   0   0
even bit =   0   1   1   1

*swap the bits*
           8 7 6 5 4 3 2 1
odd bit  = 0   1   1   1
even bit =   1   1   0   0

*merge these bits*

new n = 01111010
n= 122


*** steps to imp 
1) separate the odd bit
   - can be done by n & 1010 1010 or (n & 0x AAAA AAAA) i.e 0xAAAAAAAAA is a hexa-decimel of 10101010
2) separate the even bit
   - can be done by n & 0101 0101 or (n & 0x5555 5555) i e 0x55555555 is the hexadecimal of 01010101
3) merge the odd and even bit by OR operator
   -  n & 0xAAAAAAAA OR n & 0x55555555.

**** code
~
int oddOrEven(n)
{
   return ((n & 0xAAAAAAAA) | (n & )x55555555));
}
~


** 8) count the number of trailing zero in a binary
we use the same logic of position of rigit most set bit qus(2)



** DONE 9) Reversing bits of an 32 bit integer variable

32 bit = 00000000 00000000 00000000 00000000

take the value of 8 bit two pointers
l = 1 and 1 <<l
f =   and f >> 1

res                      n=1
7 6 5 4 3 2 1 0          7 6 5 4 3 2 1 0   
0 0 0 0 0 0 0 0          0 0 0 0 0 0 0 1

1) shift the last bit to first pos
           7 6 5 4 3 2 1 0            
n        = 0 0 0 0 0 0 0 1
1<<f     = 1 0 0 0 0 0 0 0  
n & 1<<f = 0 0 0 0 0 0 0 0

2) shift the first pos to last pos
           7 6 5 4 3 2 1 0
n        = 0 0 0 0 0 0 0 1
1<<l     = 0 0 0 0 0 0 0 1
n & 1<<l = 0 0 0 0 0 0 0 1

n & 1<<l is not zero so res += 1<<f;
      7 6 5 4 3 2 1 0
res = 1 0 0 0 0 0 0 0 

  
*** code 
~
public static void main(String[] args) 
{
	int n=1,f=31,l=0,res=0;
	System.out.println(Integer.toBinaryString(n));
	while(f>l) 
	{			
		if((n & (1<<f)) !=0) 
		{	
			res+=f;
		}
		if((n & 1<<l) !=0 ) 
		{			
			res +=(1<<f);
		}
		System.out.println(res+" "+(1<<f)+" "+(1<<l));
		f--;
		l++;
	}
}
~


** TODO  10) N-th palindromic binary representation
Note :
1) Consider the first number whose binary representation is palondromw as 1 instead of 0
      in binary 1 is palindrome so
2) Don't consider the leading the leading zeros, while considering the binary representation
   010 -
   
*Observation*
Don't consider any binary representation which has trailing and leading zeros, i.e the binary representation should start and end with one.

|  do | don't |
|   1 |   010 |
|  11 |       |
| 101 |       |

|------+---------------+--------+----------------+--------------------------------------|
| n-th | Binary number | Length | Combintaion    |                                      |
|------+---------------+--------+----------------+--------------------------------------|
|    1 | 1             |      1 | aa          1  | 2^0                                  |
|------+---------------+--------+----------------+--------------------------------------|
|    2 | 11            |      2 | aba         1  | 2^0 b is the 1 combination           |
|------+---------------+--------+----------------+--------------------------------------|
|    3 | 101           |      3 | a-b-a       2  | 2^1 2 COMBINATIONS 1 BIT CAN CHANGE  |
|    4 | 111           |      3 |                | - 0 or 1 is said to be 2 combination |
|      |               |        |                |                                      |
|------+---------------+--------+----------------+--------------------------------------|
|    5 | 1001          |      4 | a-bb-a      2  | 2^1                                  |
|    6 | 1111          |      4 |                | - 0 or 1 is said to be 2 combination |
|      |               |        |                | - b are the 1 bit can change         |
|------+---------------+--------+----------------+--------------------------------------|
|    7 | 10001         |      5 | a-bcb-a     4  | 2^2 2 combination 2 bit can change   |
|    8 | 10101         |      5 |                | - 0 or 1 is said to be 2 combination |
|    9 | 11011         |      5 |                | - bc are the 2 bit can change        |
|   10 | 11111         |      5 |                |                                      |
|------+---------------+--------+----------------+--------------------------------------|
|   11 | 100001        |      6 | a-bccb-a    4  | 2^2                                  |
|   12 | 101101        |      6 |                | - 0 or 1 is said to be 2 combination |
|   13 | 110011        |      6 |                | - bc are the 2 bit can change        |
|   14 | 111111        |      6 |                |                                      |
|------+---------------+--------+----------------+--------------------------------------|
|   15 | 100 0 001     |      7 | a-bcdcb-a   8  | 2^3 2 combination 3 bit can change   |
|   16 | 100 1 001     |        |                | - 0 or 1 is said to be 2 combination |
|   17 | 101 0 101     |        |                | - bcd are the 3 bit can change       |
|   18 | 101 1 101     |        |                |                                      |
|   19 | 110 0 011     |        |                |                                      |
|   20 | 110 1 011     |        |                |                                      |
|   21 | 111 0 111     |        |                |                                      |
|   22 | 111 1 111     |        |                |                                      |
|------+---------------+--------+----------------+--------------------------------------|
|   23 | 1000 0001     |      8 | a-bcddcb-a   8 |                                      |
|   24 | 1001 1001     |        |                | - 0 or 1 is said to be 2 combination |
|   25 | 1011 1101     |        |                | - bcd are the 3 bit can change       |
|   26 | 1010 0101     |        |                |                                      |
|   27 | 1100 0011     |        |                |                                      |
|   28 | 1101 1011     |        |                |                                      |
|   29 | 1110 0111     |        |                |                                      |
|   30 | 1111 1111     |        |                |                                      |
|------+---------------+--------+----------------+--------------------------------------|

palindromic binary representation 
*Lets take 7*
look the *bcd column* on the table. It is a binary represetation of 0,1,2,3,4,5,6,7. 

|-----------|
| a bcd cba |
|-----------|
| 1 000 001 |
| 1 001 001 |
| 1 010 101 |
| 1 011 101 |
| 1 100 011 |
| 1 101 011 |
| 1 110 111 |
| 1 111 111 |
|-----------|

how to solve this 
n =21

first find the length of the n in binary form. l =7 
21 = 


** TODO 11) maximum and value of array 


* recursion
** basic 
a function calling itself

eg. 
void fun()
{
  .
  .
  .
  .
  fun();
}

stack segment is has store the fun(). Infinitily recursion is run, it become StackOverflowError and end the program
stack can auto-scrink and auto-extends.
program for stackOverFlowError:

class Main{

static void fun(int n)
{
  system.out.println(n);
  fun(n-1);
}

public static void main(String arg[])
{
   fun(3); //calling fun
}

}
------------------------------------------------
Output :
3 
2
1
0
-1
2
.
.
.
.
.
.
Exception stackOverFlowError
-------------------------------------------------

*To avoid stackOverFlowError, we want to terminate the program by return at a base condition*

// if n==0 is a base condition and return from the method.

Program :

class Main
{
static void fun(int n)
{
  if(n==0)
     return ;
  system.out.println(n);
  fun(n-1);
}

public static void main(String arg[])
{
   fun(3); //calling fun
}

}

Output :
3
2
1

Diagram of stack segment

1) call the stack start the main function.

| 1111111111111111111111111111111 |                  
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2            main()           2 |
| 2                             2 |
| 2222222222222222222222222222222 |
| 1111111111111111111111111111111 |

2) the fun is fetch on stack segment

| 1111111111111111111111111111111 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2           fun(3)            2 |
| 2                             2 |
| 2222222222222222222222222222222 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2           main()            2 |
| 2                             2 |
| 2222222222222222222222222222222 |
| 1111111111111111111111111111111 |

3) one by one the stack full by call the function of itself

| 1111111111111111111111111111111 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2          fun(0)contion      2 |----------> condition satisifies then the return and pop from the stack segment
| 2                             2 |
| 2222222222222222222222222222222 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2           fun(1)            2 |
| 2                             2 |
| 2222222222222222222222222222222 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2            fun(2)           2 |
| 2                             2 |
| 2222222222222222222222222222222 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2           fun(3)            2 |
| 2                             2 |
| 2222222222222222222222222222222 |
|                                 |
| 2222222222222222222222222222222 |
| 2                             2 |
| 2           main()            2 |
| 2                             2 |
| 2222222222222222222222222222222 |
| 1111111111111111111111111111111 |

4) the condition condition pop one by one downwards upto start.

*Application of Recursion*
1) Dynamic programming
2) Tree traversal
3) Divide and conquer Algorithms(binary search, merge sort, quick sort)


** print 1st N natural number (magic of recursion)

*** code
private static void forwardprint(int i) 
{
	if(i<1)
		return;
	forwardprint(i-1);
	System.out.print(i+" ");	
}

*** explaination 
after we do n to 0 but the result is store in forward 1 2 3 4 . . . . .

*After the function return then one by one execute the remaining code and go to preview fun*

function go first from 10 9 8 7 6 5 4 3 2 1. when fun(0) the next funtion is if condition satisified.

pop the fun(0), move to preview fun(1) and excute the system.out.print(n); => 1 
pop the fun(1), move to preview fun(2) and excute the system.out.print(n); => 2
pop the fun(2), move to preview fun(3) and excute the system.out.print(n); => 3  
pop the fun(3), move to preview fun(4) and excute the system.out.print(n); => 4 
pop the fun(4), move to preview fun(5) and excute the system.out.print(n); => 5 
pop the fun(5), move to preview fun(6) and excute the system.out.print(n); => 6
                         :
			 :
			 :
pop the fun(9), move to preview fun(1) and excute the system.out.print(n); => 10 
pop the fun(10), move to the main function.


** find factorial of a number using recursion  
5! = 5*4*3*2*1 =120

n! =n * (n-1)! 
5! = 5 * (5-1)! => n=4 in next function
4! = 4 * (4-1)! => n=3 in next function
3! = 3 * (3-1)! => n=2 in next function
2! = 2 * (2-1)! => n=1 in next function
1! = return 1;



*** stack seqment
push the function 
n=3
|----------+-----------+-----------+----------|
| main()   | 3*fact(2) | 2*fact(1) | return 1 |
|----------+-----------+-----------+----------|
| main()   | 3*fact(2) | 2*1       | pop (1)  |
|----------+-----------+-----------+----------|
| main()   | 3* 2      | pop (2)   | pop      |
|----------+-----------+-----------+----------|
| main() 6 | pop(6)    | pop       | pop      |
|----------+-----------+-----------+----------|

**** code


** Fibonacci series using recursion

Three rules of recursion
1) Can it be broken down to smaller problem
2) Are the result dependent on each other
3) Does it have a *base condition*

1 1 2 3 5 8 13 21 . . . . . . . .


dependecy is dependents of pre term and 

recursion relationship:

fibo(n) = fibo(n-1) + fibo(n-2)
eg
n=6 so = (5+4+3+2+1) + (4+3+2+1)
it can be recursion tree
*** Recursion tree
1) N=5 , tree top 5
                 5
2) move from left to right, which means fibo(n-1) then fibo(n-2)
             1)      5 (3+2)
             11)/ 3      \ 12) 2
     2)   fibo(4) (2+1)    fib(3) (1+1)
        2 7)/ \ 8) 1     1 9)  /  \ 10) 1
 3)   fibo(3)   fibo(2)  fibo(2)  fibo(1)
    5) 1 /  \ 6) 1
4)  fibo(2)  fibo(1)

**** code
~
static intfib(int n)
{
   if(n==1 || n==2)
     return 1;
  return fib(n-1)+fib(n-2);
}
~


** count the number of digits
n=12345

        12345 5
	  |   +
	1234  1  4
	  |   +
	 123  1  3
          |   +
	 12   1  2
	  |   +
	  1   1  1   
	  |   +
	  0   0 

*** code 
int count(int n)
{
   if(n==0)
     return 0;
   return count(n/10)+1;
}


** find the sum of digits of a number using recursion.
n=5351.
1) output is depands on preview one
   535 + 1
   53 +5+1
   5 + 3 + 5 + 1
   0 + 5 + 3 + 5+ 1

2) base condition is n != 0

*** code
~
private static int sum(int i) {
	if(i<=0)
		return 0;
		System.out.println(i);
	return sum(i/10)+ (i%10);	
}
~


** reverse a string using recursion
   0123
s="abcd"

r="" => string is an immutable.

concatate the d c b a in string r by int i

*** code
~
private static String reverseString(String string,String rev,int i) {
	if(i==0)
		return rev;
	System.out.println(rev);
	return reverseString(string,rev+string.charAt(i-1),i-1);
}
~


** if a string is palindrome using recursion
*** using above method revese a string  
**** code
~
public static void main(String[] args) {
	String s1= "malayalam",s="";
	s=reverseString(s1,s,s1.length());	
	System.out.println(s);
	if(s1.equals(s))
		System.out.println("palindrome");
	else
		System.out.println("not");	
}

private static String reverseString(String string,String rev,int i) {
	if(i==0)
		return rev;
	System.out.println(rev);
	return reverseString(string,rev+string.charAt(i-1),i-1);
}
~

*** using two pointer recursion
**** code
~
private static boolean isPal(String s1, int start,int end) 
{	
	if(s1.charAt(start) != s1.charAt(end))
	       return false;
	if(start >= end)
		return true;
	return isPal(s1,start+1,end-1);
}

~


** sum of all elements in an Array
*** code
~
private static int sumArray(int[] a,int start) {
	if(start ==a.length)
		return 0;   // return value;
	return sumArray(a, start+1)+a[start];
}
~


** solution of josephus problem using recursion
eg. 7 person and 3rd person is dead

| pos      | Array n=7       | formula (jos(N-1,k)+k)%N |
|----------+-----------------+--------------------------|
| (N,k)    | 0 1  2  3 4 5 6 |                          |
| jos(7,3) | a b +c+ d e f g | (0+3)%N = 3              |
| jos(6,3) | d e +f+ g a b   | (1+3)%N = 4              |
| jos(5,3) | g a +b+ d e     | (2+3)%N = 5              |
| jos(4,3) | d e +g+ a       | (3+3)%N = 6              |
| jos(3,3) | a d +e+         | (4+3)%N = 0              |
| jos(2,3) | +a+ d           | (5+3)%N = 1              |
| jos(1,3) | d               | (6+3)%N = 2              |
|----------+-----------------+--------------------------|

*** make this formula 
1) take pos 7 and pos 6
       0 1  2  3 4 5 6 
       a b +c+ d e f g
       d e  f  g a b

*here the pos 6 and pos* 
 | letter | pos 6 | pos 7 |
 | d      |     0 |     3 |
 | e      |     1 |     4 |
 | f      |     2 |     5 |
 | g      |     3 |     6 |
 | a      |     4 |     0 |
 | b      |     5 |     1 |
 | c      |       |     2 |

from pos 7 to pos 6 we equalate

0 + 3 = 3
1 + 3 = 4
2 + 3 = 5
3 + 3 = 6
here we can 3(k) 
4 + 3 = 7 ...... so equate to 0 
7 % 7 = 0 ......it why we use % 7(N)

*now we got*
(0 + 3) % 7 = 3
(1 + 3) % 7 = 4
(2 + 3) % 7 = 5
(3 + 3) % 7 = 6
(4 + 3) % 7 = 1
(5 + 3) % 7 = 2
(6 + 3) ..... we cannot do so (jos(n-1),k)+k)%n

*At last*
n=7 
((n-1 , k) +k)% n
((7-1 , 3) +3)% 7 
((6-1 , 3) +3)% 6
((5-1 , 3) +3)% 5
((4-1 , 3) +3)% 4
        :
	:
    if(n==1)
        return 0;

**** code
~
private static int jos(int n, int k) {
	if(n==1)
		return 0;
	return (jos(n-1,k)+k)%n;
}
~


** Generate all balanced parentheses using recursion
n= 2
 ()()
 (())
create a char array of size n*2 

take  i=0 , o=0 and c = 0 
   o - opening bracket
   c - closing bracket

*two conditions*
1) o < n
   i+1 , o+1
2) c < o
   i+1 , c+1

*** code
~
public static void main(String[] args) 
{
	int n=3;
	char ar[]= new char[n*2];
	balpare(ar,n,0,0,0);
}

private static void balpare(char[] ar, int n, int i, int o, int c) {
	if(i==ar.length)
	{
		System.out.println(ar);
		return;
	}
	
	if(o<n)
	{
		ar[i]='(';
		balpare(ar, n, i+1, o+1, c);
	}

	if(c<o)
	{
		ar[i]=')';
		balpare(ar, n, i+1, o, c+1);
	}
}
~


** Subsequence of a given string 
*subsequence*
     Subsequence of a given sequence is a sequence that can be derived 
from the given sequence by deleting some or no elements without changing tha order of the remaining elements.
eg. abc 
 subsequence abc, bc, ac,ab, a, c, b, "empty";

*No of subsequence are 2^n*

n = 3
2^3 = 8 = "",a, b, c, ab, ac, bc, abc,

*** can it be solved recursively?
1) can it be broken down into smaller problem ?
| string s | ans                            |
|----------+--------------------------------|
| c        | c  -> c, _                     |
| bc       | bc -> c, _, bc, b              |
| abc      | abc -> c, _, bc, b,ac,a,abc,ab |
|----------+---- ----------------------------|
2) Are the solution of the problem dependent on each other ?
3) Is there a base condition.

 

**


** Print all the Permutation of a string using Recursion





* Binary search
** span of an array
 span = max value of array - min value of array;
*** code
private static int span(int[] a) 
{
	int min=a[0],max=a[0];
	for(int i=1;i<a.length;i++)
	{
		if(min>a[i])
		        min=a[i];
		if(max<a[i])
			max=a[i];
	}
	System.out.println(min+" "+max);
	return max-min;
}


** second largest element in an array
*** code
private static void secondLargest(int[] a) 
{
	int sec=a[0],max=a[0];
	for(int i=1;i<a.length;i++)
	{
		if(max<a[i])
		{
			sec=max;
			max=a[i];
		}
		else if(sec<a[i])
			sec=a[i];
		
	}
	System.out.println(sec+" "+max);
}


** find ceil and floor of an number in a searched array
 a = {19,23,56,61,72,88,92};
ceil(68) = 72
 - because 68 is not in that array. It between 61 to 72.
floor(68) = 61 and ceil(68) = 72.

*** 

**** code
~
	private static void ceilAndFloorNumberInSortedArray() 
{	
	int a[]= {19,23,56,61,72,88,92};
	int find=100,l=0,h=a.length;
	int ceil=0,floor=0;
	boolean b=true;
// to check the value greater or lesser the given value
	if(a[0]>= find)
	{
		ceil=floor=a[0];
		b=false;
	}
	else if(a[h-1] <= find)
	{
		ceil=floor=a[h-1];
		b=false;
	}
// binary search for value
while(h>=l && b==true)
{
	System.out.println(l+" "+h);
	int m = (h+l)/2;
	if(a[m]==find)
	{
		ceil = floor = a[m];
		b=false;
	}
	else if(a[m]> find)
		h=m-1;
	else
		l=m+1;
}
	if(ceil==0)
	{
		ceil =a[h];
		floor =a[l];
	}
	System.out.println(l+" "+h+" "+ceil+" "+floor);
}
~


** search an element in Bitonic Array 
*Bitonic array are an Array that values are increase at certain index the value are decrease*
eg. 1 3 5 6 8 10 9 7 6.

after value 10 the value start decrease.
10 is bitonic element and 5 index is the bitonic point.

*** explaination 
    eg. 1 3 5 6 8 10 9 7 6.
    1) find the point where the array can be split (bitonic point)
       - do a binary search to find bitonic search
       - condtion from l =0 , h=lenght and m = (l+h)/2
       - if( a[m] > a[m-1] && a[m] < a[m+1] then return m; -> m is mid point or bitonic search
    2) Check if the element is at the bitonic point. If yes return the Bitonic point
       if(key == a[m]) ascending binary search and descending binary search

    3) Otherwise perform the binary search on left and right side of the Bitonic point using binary search.
       
**** code 
~
public static void main(String[] args) {
	int b[] = {1,2,6,7,10,14,11,9,8,4,3};
//	int b[] = {55,32,23,21,12,11,13,15,24,35,65};
	int key =14;
	// find bitonic index
	int bitonic =findBitonic(b);
	System.out.println(bitonic);
	if(b[bitonic]==key)
		System.out.println("true");
	else
	{
		if(b[bitonic]>b[bitonic-1])
		{
			if(ascendingBinarySearch(b,0,bitonic-1,key) |descendingBinarySearch(b,bitonic+1,b.length-1,key))
				System.out.println("true");
			else
				System.out.println("false");
		}
		else
		{
			if(descendingBinarySearch(b,0,bitonic-1,key) | ascendingBinarySearch(b,bitonic+1,b.length-1,key)) System.out.println("true");
			else System.out.println("false");
		}
	}
}

private static boolean descendingBinarySearch(int[] b, int l, int h,int key) {
	while(l<=h)
	{
		int m=(l+h)/2;
		if(b[m]==key)
			return true;
		if(key>m)
			l=m+1;
		else
			h=m-1;
	}
	return false;
}

private static boolean ascendingBinarySearch(int[] b, int l,int h, int key) {
		
	while(l<=h)
	{
		int m=(l+h)/2;
		if(b[m]==key)
			return true;
		if(key>m)
			l=m+1;
		else
			h=m-1;
	}
	return false;
}

private static int findBitonic(int[] a) {
	int l=0,h=a.length-1;
	while(l<=h)
	{
		int m=(l+h)/2;
		if(a[m] > a[m-1] && a[m]> a[m+1] || a[m] < a[m-1] && a[m] < a[m+1])
			return m;
		else if(a[m]> a[m-1] && a[m] < a[m+1])
			l=m+1;
		else
			h=m-1;
	}
	
	return -1;
}
~


** count of smaller or equal element in an sorted array
case 1: no duplicates 
a = 2,6,12,18,21,26,33,42
k=26;
count = 6
by using binary search and return n+1;

case 2: duplicates exists
a = 2,6,12,18,21,26,26,26
k=26
count = 6 but we need 8 because of duplicates.

case 3: k does not exist 
a = 2,6,12,18,21,26,33,42
k=25


*** solutions is used to check binary search and cound the number of duplicates 

**** code
~
public static void main(String[] args) {
	int b[]= {2,6,12,18,21,24,26,26,26,26,33,42},find=25;
	System.out.println(countSearch(b,find));
}

private static int countSearch(int[] b, int find) {
	int l=0,h=b.length-1,m = 0;
	while(l<=h)
	{
		 m = (l+h)/2;
		if(b[m]== find)
		{
			break;
		}
		else if(b[m] > find)
			h=m-1;
		else
			l=l+1;
	}
	
	if(b[m]!=find) // element is not present
		return m+1;

	while(m<b.length-1) // if the element is present and dulplicates are available
	{
		if(b[m+1]!=find)
			return m;
		m++;
	}
	return -1;
}
~


** Find the first and last position of an element in a sorted array 
Input : a[]={5,7,7,8,8,10} target = 8
Output: 3,4


Input : a[]={5,7,7,8,8,10} target = 6
output: [-1,-1]

*** explaination
1) find the number if found
   1) again binary search find pos ()
2) else return new int[] {-1,-1}

**** code
~
public static void main(String[] args) {
	int a[]={5,7,7,8,10}, target = 6;
	int b[]= findFirstAndLast(a,target);
	System.out.println(Arrays.toString(b));
}

private static int[] findFirstAndLast(int[] a, int target) {
	int l=0,h=a.length-1;
	while(l<=h)
	{
		int m = (l+h)/2;
		if(a[m]==target)
			return firstAndLast(a,m,target);
		else if(m > target)
			h= m-1;
		else
			l= m+1;
	}
	return new int[]{-1,-1};
}

private static int[] firstAndLast(int[] a, int m,int target) {
	int l1=0,h1=m-1,l2=m+1,h2=a.length-1,m1=m,m2=m;
	while(l1<=h1 && a[m1-1]==target)
	{
		m1 = (l1+h1)/2;
		if(a[m1]==target)
			break;
		else if(m1 > target)
			h1= m1-1;
		else
			l1= m1+1;
	}
		
	while(l2<=h2&& a[m+1]==target)
	{
		 m2 = (l2+h2)/2;
		if(a[m2]==target)
			break;
		else if(m2 > target)
			h2= m2-1;
		else
			l2= m2+1;
	}
	return new int[] {m1,m2};
}
~


** search in rotated sorted Array

input : a[]={4,5,6,7,0,1,2} , target = 0,
output: 4

*** explaination binary search (pos) inside use to find between the values  
binary search arr first

   4 5 6 7 0 1 2   target =5

   1) if(a[m] == target)
       return pos;
   2) else if(a[m] > target)
      {
            if(a[l]=<target && a[m] > target) // this condition false target occurs in left side
	        h= m-1;
	    else // this condition occurs on right side
	        l= m+1;
      }
   3) else
      {
            if(a[m]<target && a[h]>=target)
	        l=m+1;
	    else
                h=m-1;
      }

**** code
~
private static int rotatation(int[] a, int target) 
{
	int l=0,h=a.length-1;
	while(l<=h)
	{
		int m= (l+h)/2;
		if(a[m]==target)
			return m;
		else if(a[m]>target)
		{
			if(a[l]<=target && a[m]>target)
				h=m-1;
			else
				l=m+1;
		}
		else
		{
     		        if(a[h]>=target && a[m]<target)
				l=m+1;
		        else
				h=m-1;
		}
	}
	return -1;
}
~


** wood cutting program 
*** explain
 given an array and target of minimum no. of wood to cut
 eg. a[]={20,15,10,17} target =7
     a[] = {20,15,10,17} target =8 condition is l=m

1) find the maximum value of array and assign are as high
2) binary search low = 0, high=max(a)
    int m =(low+high)/2;
    wc = add(a,m)   // add the wood to be cut
   1) if(low==m || wc == target)
   2) else (low < target)
        h=m;
   3) else l=m;
3) add(a,m)
    for(0,a.le)
      if(a[i]>m)
         sum += a[i]-m;
  return sum;

**** code
~
public static void main(String[] args) 
{
	int a[]= {20,15,10,17},target=7;
	int b =woodcutting(a,target);
	System.out.println(b);
}

private static int woodcutting(int[] a, int target) 
{
	//find max of array
	int l=0,h=a[0];
	for(int i=1;i<a.length;i++)
	{
		if(a[i]>h)
			h=a[i];
	}
	System.out.println(h);
	while(true)
	{
		int m=(l+h)/2;
		int wc = addArray(a,m);
		if(wc == target || l == m)
			return m;
		else if(m > wc)
			h=m;
		else
		        l=m;
		System.out.println(l+" "+m+" "+h);
	}
}

private static int addArray(int[] a, int m) 
{
	int sum=0;
	for(int i=0;i<a.length;i++)
		if(a[i] > m) // important condition, otherwise it add negative value
			sum+=a[i]-m;
	System.out.println("sum"+sum);
	return sum;
}
~


** Find the median of two sorted arrays
*Median* 
total number of elements div 2

median = total number of elements / 2

Case 1: odd number
     0 1 2 3 4 5  6  7  8
m -> 1 3 4 6 7 8 17 19 21  
 
median = 8/2 = 4 pos has no 7.

case 2: even numbers
     0 1 2 3 4 5  6  7  8  9
m -> 1 3 5 6 7 8 17 19 21 25

median =(pos of 4) + (pos of 5)/2= (7+8)/2 = 7.5

*** explaination (merge sort logic i understand) O(m+n)
      0  1  2  3          0 1 2  3  4  5
a1 -> 1  3  8 17     a2-> 5 6 7 19 21 25

1) create a new array of size(a1.length + a2.length)
   i=0,j=0,k=0
   while(i<ar1.length && j<ar.length)
   {
    if(a1[i] <a[j])
    {
      a[k]=a1[i];
       k++;
       i++;
    }
    else
    {
      a[k]=a2[j];
      k++;
      j++;
     }
   }

a =  1 3 5 6 7 8 17 

2) put remaining by same condition
 while(i<ar1.length)
 {
    a[k]=a1[i];
       k++;
       i++;
 }

while(j< ar2.length)
{
    a[k]=a1[j];
       k++;
       j++;
}

3) After we find the array a

if(a.length % 2 == 0)
{
   int mid = a.lenght/2;
   ans = (float) (a[mid] + m[mid+1])/2;
}
else
{
   int mid = a.lenght/2;
   ans = a[mid];   
}
**** code 

*** optimize the 

    
* Arrays
** Program to check if a given array is sorted or not
    0 1 2 3  4  5  6
a-> 2 4 6 8 10 12 14

for(0 to i< a.lenght-1){
 if(a[i]>a[i+1] 
    return false;
}
 return true;


** Reverse an array in java
    0 1 2 3  4  5  6
a-> 2 4 6 8 10 12 14

*** swap the i and j upto (i<j)


** Find sqrt / floor of sqrt of a number
Given an integer N.
1) Compute and return the sqrt of N. 
2) If N is not a perfect sq, return floor(sqrt(n)).
3) Do not use sqrt function from standard library.
4) Note : Do not use sort function from standard library. User are expected to solve this in O(logN) time.

1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
 
1     2       3                    4                          5 

*** i*i < n 

*** binarysearch(n/2)


** Remove Duplicates from sorted Array.
      0 1 2 3 4 5 6
ar -> 2 2 3 3 4 6 6

temp -> 2 3 4 6

*** separate array and two pointer
*** same array and do two pointer
      i j
ar -> 2 2 3 3 4 6 6

**** code 


** Rotate an Array  
*** brute force my approch

*** reverse 0-k and k-1 to n then revese 0 to n


** move zeros to end of an array
*** two pointer 


** find subarray
*** contiguous
ar = 1 2 3 4 5
subarrays are 
1 
1 2 
1 2 3 
1 2 3 4 
1 2 3 4 5

2 
2 3
2 3 4 
2 3 4 5

3 
3 4
3 4 5

4
4 5

5


*** code
for(i =1 ; i<=a.length;i++){
for(j=i; j<a.length;j++){
 
}
}


** find the inverse of an array

a -> 2 3 1 0 4

b -> 3 2 0 1 4
new array b[a.lenght]

inverse of an array 
b[a[0]]= b[2] = 0
b[a[1]]= b[3] = 1
b[a[2]]= b[1] = 2
b[a[3]]= b[0] = 3
b[a[4]]= b[4] = 4

*** code
int a[n]={2,1,0,3,4},b[n];
for(int i=0;i<a.length;i++)
 b[a[i]]=i;


** find leaders in an array

a -> 8 11 5 11 7 6 3

leaders means -> an element is leader, if it is greater than  all the elements to its right side.
And the rightmost element is always a leader.

output : 11, 7, 6, 3

*** 

*** ending to begining


** Frequency of element in a sorted array

** Maximum consecutive ones in an array
      0 1 2 3 4 5 6 7 8
arr = 0 1 1 0 0 1 1 1 0

maximum consecutive ones = 3

*** count and maxcount upto 



** Maximum subarray sum

** find majority element 
*** optimius  

** Maximum length of alternating even odd subarray
     0 1 2 3   out   ans
ar - 2 3 4 6 -   3 - 2 3 4

ar - 5 6 7 8 -   4 - 5 6 7 8

ar - 

** minimum consecutive flips 


* String
** Anagram
** substring
